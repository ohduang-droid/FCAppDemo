import { useEffect, useRef, useState, useCallback } from 'react';
import { useLocation, useNavigate } from "react-router-dom";
import {
  PlayerSurface,
  ChannelHubOverlay,
  OriginalContentView,
  SubscriptionOverlay
} from '@/components/player';
import { mockChannel, mockEpisodes } from '@/data/mockData';
import { Episode } from '@/types/player';
import { useAiNewsTts } from "@/hooks/useAiNewsTts";
import { useRecapAudio } from "@/hooks/useRecapAudio";
import { getDefaultArticleSummary } from "@/lib/articleSummary";

const Index = () => {
  const navigate = useNavigate();
  const location = useLocation();

  // Player state
  const [currentEpisode, setCurrentEpisode] = useState<Episode>(mockEpisodes[1]); // Start with middle episode for testing
  const [volume, setVolume] = useState(0.7);
  const [channel, setChannel] = useState(mockChannel);

  // Overlay state
  const [isChannelHubOpen, setIsChannelHubOpen] = useState(false);
  const [isOriginalContentOpen, setIsOriginalContentOpen] = useState(false);
  const [isSubscriptionOpen, setIsSubscriptionOpen] = useState(false);


  // Auto-play "article recap" on refresh (mock); dev team will replace with real summary + audio
  const fallbackDurationSeconds = 3 * 60;

  const formatTime = (seconds: number) => {
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  };

  const autoPlayOnceRef = useRef(false);

  const recapAudio = useRecapAudio({
    src: "/recap.wav",
    fallbackDurationSeconds,
    onEnd: () => {
      // notifications disabled
    },
  });

  // Use real audio player values
  const effectiveDurationSeconds = recapAudio.durationSeconds;
  const effectiveCurrentSeconds = recapAudio.currentSeconds;
  const effectiveProgress = recapAudio.progress;
  const effectiveIsPlaying = recapAudio.isPlaying;
  const currentTimeSeconds = effectiveCurrentSeconds;
  const remainingSeconds = effectiveDurationSeconds - effectiveCurrentSeconds;

  // Handlers
  const handleTogglePlay = useCallback(() => {
    if (!recapAudio.supported) {
      return;
    }
    recapAudio.toggle();
  }, [recapAudio]);

  // Auto-play on page load (best-effort; may be blocked by browser until user gesture)
  useEffect(() => {
    if (autoPlayOnceRef.current) return;
    autoPlayOnceRef.current = true;

    if (!recapAudio.supported) return;
    // Try to start immediately
    recapAudio.play();
  }, [recapAudio]);

  const handleSeek = useCallback((newProgress: number) => {
    recapAudio.seekSeconds((newProgress / 100) * effectiveDurationSeconds);
  }, [effectiveDurationSeconds, recapAudio]);

  const handleVolumeChange = useCallback((newVolume: number) => {
    setVolume(newVolume);
    recapAudio.setVolume(newVolume);
  }, [recapAudio]);

  const handleSkipBack = useCallback(() => {
    recapAudio.seekSeconds(recapAudio.currentSeconds - 15);
  }, [recapAudio]);

  const handleSkipForward = useCallback(() => {
    recapAudio.seekSeconds(recapAudio.currentSeconds + 15);
  }, [recapAudio]);



  // Click "Subscribe" button - open subscription page
  const handleOpenSubscription = useCallback(() => {
    setIsSubscriptionOpen(true);
  }, []);

  // Optional entry-points from other pages (e.g. Channel page).
  useEffect(() => {
    const state = (location.state ?? null) as
      | {
        openSubscription?: boolean;
        playEpisodeId?: string;
        channel?: typeof channel;
        episodes?: Episode[];
      }
      | null;
    if (!state) return;

    if (state.openSubscription) {
      setIsSubscriptionOpen(true);
    }

    if (state.playEpisodeId) {
      const list = state.episodes ?? mockEpisodes;
      const nextEpisode = list.find((e) => e.id === state.playEpisodeId) ?? null;
      if (nextEpisode) {
        setCurrentEpisode(nextEpisode);
        setProgress(nextEpisode.progress || 0);
      }
      if (state.channel) setChannel(state.channel);
      // Donâ€™t auto-start TTS when coming from an episode selection
      setIsPlaying(false);
      stopTts();
    }

    // Clear navigation state so refresh/back doesn't repeatedly re-trigger.
    navigate(".", { replace: true, state: null });
  }, [location.state, navigate]);

  const openOriginalUrl = useCallback(() => {
    // Open the original URL directly (same behavior as the ExternalLink button).
    const url = currentEpisode.originalUrl;
    if (typeof window !== "undefined" && url) {
      const opened = window.open(url, "_blank", "noopener,noreferrer");
      // If popup is blocked, fall back to same-tab navigation.
      if (!opened) window.location.assign(url);
      return;
    }

    // Fallback (should be rare): show the in-app full issue view.
    setIsOriginalContentOpen(true);
  }, [currentEpisode.originalUrl]);

  const handleViewOriginal = useCallback(() => {
    openOriginalUrl();
  }, [openOriginalUrl]);

  // Confirm subscription - after successful subscription, auto-open the external original URL
  const handleConfirmSubscription = useCallback((plan: 'annual' | 'monthly' | 'free') => {
    if (plan === 'free') {
      setIsSubscriptionOpen(false);
      return;
    }

    setChannel(prev => ({ ...prev, isSubscribed: true }));
    setIsSubscriptionOpen(false);
    setIsChannelHubOpen(false);

    setTimeout(() => {
      openOriginalUrl();
    }, 500);
  }, [openOriginalUrl]);

  const handleSelectEpisode = useCallback((episode: Episode) => {
    setCurrentEpisode(episode);
    recapAudio.play();
  }, [recapAudio]);

  // Jump to next episode - seamless transition, same interface
  const handleNextEpisode = useCallback(() => {
    const currentIndex = mockEpisodes.findIndex(ep => ep.id === currentEpisode.id);
    if (currentIndex < mockEpisodes.length - 1) {
      const nextEpisode = mockEpisodes[currentIndex + 1];
      // Switch episode seamlessly, keep current playing state
      setCurrentEpisode(nextEpisode);
      // Keep the current playing state (if playing, continue playing; if paused, stay paused)
    }
  }, [currentEpisode.id]);

  // Jump to previous episode - seamless transition, same interface
  const handlePreviousEpisode = useCallback(() => {
    const currentIndex = mockEpisodes.findIndex(ep => ep.id === currentEpisode.id);
    if (currentIndex > 0) {
      const previousEpisode = mockEpisodes[currentIndex - 1];
      // Switch episode seamlessly, keep current playing state
      setCurrentEpisode(previousEpisode);
      // Keep the current playing state (if playing, continue playing; if paused, stay paused)
    }
  }, [currentEpisode.id]);

  return (
    <>
      <audio ref={recapAudio.audioRef} src="/recap.wav" preload="auto" />
      <PlayerSurface
        episode={currentEpisode}
        channel={channel}
        isPlaying={effectiveIsPlaying}
        progress={effectiveProgress}
        currentTime={formatTime(currentTimeSeconds)}
        duration={formatTime(effectiveDurationSeconds)}
        volume={volume}
        onBack={() => navigate(-1)}
        onTogglePlay={handleTogglePlay}
        onSeek={handleSeek}
        onVolumeChange={handleVolumeChange}
        onSkipBack={handleSkipBack}
        onSkipForward={handleSkipForward}
        onOpenChannelInfo={() =>
          navigate(`/channel/${channel.id}`, { state: { channel, episodes: mockEpisodes } })
        }
        onOpenEpisodeList={() => setIsChannelHubOpen(true)}
        onSubscribe={handleOpenSubscription}
        onViewOriginal={handleViewOriginal}
        onNextEpisode={handleNextEpisode}
        onPreviousEpisode={handlePreviousEpisode}
      />

      <ChannelHubOverlay
        channel={channel}
        episodes={mockEpisodes}
        currentEpisodeId={currentEpisode.id}
        isOpen={isChannelHubOpen}
        onClose={() => setIsChannelHubOpen(false)}
        onSubscribe={handleOpenSubscription}
        onSelectEpisode={handleSelectEpisode}
      />

      <OriginalContentView
        episode={currentEpisode}
        channel={channel}
        isOpen={isOriginalContentOpen}
        onClose={() => setIsOriginalContentOpen(false)}
      />

      <SubscriptionOverlay
        channel={channel}
        isOpen={isSubscriptionOpen}
        onClose={() => setIsSubscriptionOpen(false)}
        onSubscribe={handleConfirmSubscription}
      />
    </>
  );
};

export default Index;
